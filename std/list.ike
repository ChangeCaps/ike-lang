//! List operations 

fn list::first : ['a] -> option 'a
fn list::first xs {
  match xs {
    []      -> none
    [x; ..] -> some x
  }
}

fn list::rest : ['a] -> option ['a]
fn list::rest xs {
  match xs {
    []        -> none
    [_; ..xs] -> some xs
  }
}

/// Compute the length of a list.
fn list::len : ['a] -> int
fn list::len xs {
  match xs {
    []        -> 0
    [x; ..xs] -> 1 + list::len xs
  }
}

/// Get the nth element of a list.
fn list::nth : int -> ['a] -> option 'a
fn list::nth n xs {
  match xs {
    []        -> none
    [x; ..xs] -> {
      match n {
        0 -> some x
        _ -> list::nth (n - 1) xs
      }
    }
  }
}

/// Skip the first n elements of a list.
fn list::skip : int -> ['a] -> ['a]
fn list::skip n xs {
  match xs, n {
    [], _        -> []
    [x; ..xs], 1 -> xs
    [x; ..xs], _ -> list::skip (n - 1) xs
  }
}

/// Take the first n elements of a list.
fn list::take : int -> ['a] -> ['a]
fn list::take n xs {
  match xs, n {
    [], _        -> []
    [x; ..xs], 1 -> []
    [x; ..xs], _ -> [x; ..list::take (n - 1) xs]
  }
}

/// Append two lists together.
fn list::append : ['a] -> ['a] -> ['a]
fn list::append xs ys {
  match xs {
    []          -> ys
    [x; ..xs]   -> [x; ..list::append xs ys]
  }
}

/// Concatenate a list of lists.
fn list::concat : [['a]] -> ['a]
fn list::concat xss {
  match xss {
    []          -> []
    [xs; ..xss] -> list::append xs (list::concat xss)
  }
}

/// Reverse a list.
fn list::reverse : ['a] -> ['a]
fn list::reverse xs {
  list::reverse' xs []
}

fn list::reverse' xs ys {
  match xs {
    []        -> ys
    [x; ..xs] -> list::reverse' xs [x; ..ys]
  }
}

/// Zip two lists together.
fn list::zip : ['a] -> ['b] -> ['a, 'b]
fn list::zip xs ys {
  match xs, ys {
    [], _                -> []
    _, []                -> []
    [x; ..xs], [y; ..ys] -> [x, y; ..list::zip xs ys]
  }
}

/// Unzip a list of pairs into two separate lists.
fn list::unzip : ['a, 'b] -> ['a], ['b]
fn list::unzip xs {
  match xs {
    []           -> [], []
    [x, y; ..xs] -> {
      let xs, ys = list::unzip xs
      [x; ..xs], [y; ..ys]
    }
  }
}

/// Filter a list based on a predicate.
fn list::filter : ('a -> bool) -> ['a] -> ['a]
fn list::filter f xs {
  match xs {
    []          -> []
    [x; ..xs]   -> {
      match f x {
        true  -> [x; ..list::filter f xs]
        false -> list::filter f xs
      }
    }
  }
}

/// Map a function over a list.
fn list::map : ('a -> 'b) -> ['a] -> ['b]
fn list::map f xs {
  match xs {
    []          -> []
    [x; ..xs]   -> [f x; ..list::map f xs]
  }
}

/// Filter a list and map the results using a function.
fn list::filter-map : ('a -> option 'b) -> ['a] -> ['b]
fn list::filter-map f xs {
  match xs {
    []          -> []
    [x; ..xs]   -> {
      match f x {
        none    -> list::filter-map f xs
        some y  -> [y; ..list::filter-map f xs]
      }
    }
  }
}

/// Check all elements of a list against a predicate.
fn list::all : ('a -> bool) -> ['a] -> bool
fn list::all f xs {
  match xs {
    []        -> true
    [x; ..xs] -> f x and list::all f xs
  }
}

/// Check if any element of a list satisfies a predicate.
fn list::any : ('a -> bool) -> ['a] -> bool
fn list::any f xs {
  match xs {
    []        -> false
    [x; ..xs] -> f x or list::any f xs
  }
}

/// Check if a list contains a specific element.
fn list::contains : 'a -> ['a] -> bool
fn list::contains x -> list::any |y| y == x

/// Find the first element in a list that satisfies a predicate.
fn list::find : ('a -> bool) -> ['a] -> option 'a
fn list::find f xs {
  match xs {
    []          -> none
    [x; ..xs]   -> {
      match f x {
        true  -> some x
        false -> list::find f xs
      }
    }
  }
}

fn list::find-map : ('a -> option 'b) -> ['a] -> option 'b
fn list::find-map f xs {
  match xs {
    []        -> none    
    [x; ..xs] -> {
      match f x {
        none    -> list::find-map f xs
        some y  -> some y
      }
    }
  }
}

/// Fold a list from the left with an accumulator.
fn list::foldl : 'a -> ('a -> 'b -> 'a) -> ['b] -> 'a
fn list::foldl acc f xs {
  match xs {
    []        -> acc
    [x; ..xs] -> list::foldl (f acc x) f xs
  }
}

/// Create an iterator over the elements of a list.
fn list::iter : ['a] -> iter 'a
fn list::iter xs {
  iter::new |_| {
    match xs {
      []        -> none
      [x; ..xs] -> some (x, list::iter xs)
    }
  }
}
