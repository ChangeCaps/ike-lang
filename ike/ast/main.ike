import ike::parse::token
import ike::span
import ike::diagnostic

import std::list
import std::string
import std::none
import std::some
import std::option
import std::result
import std::ok
import std::err

type kind = error diagnostic
          | file
          | path

          // items
          | item::import
          | item::alias
          | item::function
          | item::function::params
          | item::ascription
          | item::extern
          | item::type
          | item::generics
          | item::generic
          | item::type::union
          | item::type::union::variant
          | item::type::record
          | item::type::record::field

          // types
          | type::unit
          | type::integer
          | type::string
          | type::boolean
          | type::path
          | type::list
          | type::tuple
          | type::function
          | type::generic
          | type::inferred
          | type::paren

          // patterns
          | pattern::wildcard
          | pattern::path
          | pattern::variant
          | pattern::tuple
          | pattern::boolean
          | pattern::integer
          | pattern::string
          | pattern::list
          | pattern::list::tail
          | pattern::paren
          
          // expressions
          | expr::integer
          | expr::boolean
          | expr::string
          | expr::format
          | expr::path
          | expr::let_
          | expr::record
          | expr::record::field
          | expr::with_
          | expr::with_::field
          | expr::list
          | expr::list::tail
          | expr::tuple
          | expr::lambda
          | expr::lambda::params
          | expr::unary
          | expr::binary
          | expr::call
          | expr::pipe-left
          | expr::pipe-right
          | expr::field
          | expr::match_
          | expr::match_::arm
          | expr::paren
          | expr::block

type tree = {
  kind:     kind
  children: [child]
  span:     span
}

type child = token token, span
           | tree tree

fn child::span child {
  match child {
    token (_, span) -> span
    tree ast        -> ast.span
  }
}

fn tokens : tree -> [token]
fn tokens ast {
  ast.children
    |> list::filter-map |child| {
      match child {
        token (t, _) -> some t
        tree         -> none
      }
    }
}

fn trees : tree -> [tree]
fn trees ast {
  ast.children
    |> list::filter-map |child| {
      match child {
        token    -> none
        tree ast -> some ast
      }
    }
}

fn trees-of kind ast {
  ast
    |> trees 
    |> list::filter |ast| ast.kind == kind
}

fn assert : kind -> tree -> tree
fn assert kind ast { 
  ast.kind == kind
    |> std::assert "invalid ast, expected {kind}"

  ast
}

fn nth n ast {
  ast.children
    |> list::filter |c| {
      match c {
        token (token::whitespace, _) -> false
        token (token::newline   , _) -> false
        token (token::comment   , _) -> false
        _ -> true
      }
    }
    |> list::nth n
    |> option::assert
}

fn nth-tree n ast {
  match nth n ast {
    tree ast -> ast
    token t  -> std::panic "nth-tree #{n} was not a tree, but `{t}`"
  }
}

fn nth-ident n ast {
  match nth n ast {
    token (token::ident i, _) -> some i
    _                         -> none
  }
}

fn nth-integer n ast {
  match nth n ast {
    token (token::integer i, _) -> some i
    _                           -> none
  }
}

fn nth-string n ast {
  match nth n ast {
    token (token::string s         , _) -> some s
    token (token::format-start    s, _) -> some s
    token (token::format-continue s, _) -> some s
    token (token::format-end      s, _) -> some s
    _                          -> none
  }
}

fn first-error : tree -> result {} diagnostic
fn first-error ast {
  match errors ast {
    []      -> ok {}
    [e; ..] -> err e
  }
}

fn errors : tree -> [diagnostic]
fn errors ast {
  let kind = match ast.kind {
    error e -> [e]
    _       -> []
  }

  ast.children
    |> list::map |child| {
      match child {
        token    -> []
        tree ast -> errors ast
      }
    }
    |> list::flatten
    |> list::prepend kind
}

fn format : tree -> str
fn format ast {
  format-rec ast 0
}

fn format-rec ast indent {
  let indent' = string::repeat indent " "
  let kind = match ast.kind {
    error e -> "{indent'}error \"{e.message}\""
    kind    -> "{indent'}{ast.kind} {ast.span}"
  }

  ast.children
    |> list::filter |child| {
      match child {
        token (token::whitespace, _) -> false
        token (token::comment,    _) -> false
        _ -> true
      }
    }
    |> list::foldl kind |acc child| {
      let child = match child {
        token (t, _) -> "{indent'}  {t}"
        tree ast -> format-rec ast (indent + 2)
      }

      "{acc}\n{child}"
    }
}

fn is-expr ast -> kind::is-expr ast.kind
fn is-pattern ast -> kind::is-pattern ast.kind

fn kind::is-item kind {
  match kind {
    item::import     -> true
    item::alias      -> true
    item::function   -> true
    item::ascription -> true
    item::extern     -> true
    item::type       -> true
    _ -> false
  }
}

fn kind::is-type kind {
  match kind {
    type::unit     -> true
    type::integer  -> true
    type::string   -> true
    type::boolean  -> true
    type::path     -> true
    type::list     -> true
    type::tuple    -> true
    type::function -> true
    type::generic  -> true
    type::inferred -> true
    type::paren    -> true
    _ -> false
  }
}

fn kind::is-pattern kind {
  match kind {
    pattern::wildcard -> true
    pattern::path     -> true
    pattern::variant  -> true
    pattern::tuple    -> true
    pattern::boolean  -> true
    pattern::integer  -> true
    pattern::string   -> true
    pattern::list     -> true
    pattern::paren    -> true
    _ -> false
  }
}

fn kind::is-expr kind {
  match kind {
    expr::integer    -> true
    expr::boolean    -> true
    expr::string     -> true
    expr::format     -> true
    expr::path       -> true
    expr::let_       -> true
    expr::record     -> true
    expr::with_      -> true
    expr::list       -> true
    expr::tuple      -> true
    expr::lambda     -> true
    expr::unary      -> true
    expr::binary     -> true
    expr::call       -> true
    expr::pipe-left  -> true
    expr::pipe-right -> true
    expr::field      -> true
    expr::match_     -> true
    expr::paren      -> true
    expr::block      -> true
    _ -> false
  }
}
