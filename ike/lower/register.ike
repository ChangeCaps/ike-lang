import std::list

import ike::ir::uir
import ike::ast

fn create-module : uir::module::id -> [str] -> lcx -> uir::module::id, lcx
fn create-module mod-id path lcx {
  match path {
    []             -> mod-id, lcx
    [name; ..path] -> {
      let mod = lcx::get-module mod-id name lcx
      
      match mod {
        some id -> create-module id path lcx
        none    -> {
          let id, lcx = lcx::add-module uir::module lcx
          let lcx = lcx::put-module mod-id name id lcx
          create-module id path lcx
        }
      }
    }
  }
}

fn add-file : [str] -> ast::tree -> lcx -> lcx
fn add-file path ast lcx {
  let mod-id, lcx = create-module uir::module::root path lcx

  add-file-rec path mod-id (ast::trees ast) lcx
}

fn add-file-rec mod-path mod-id items lcx {
  match items {
    []              -> lcx
    [item; ..items] -> {
      let lcx = match item.kind {
        ast::item::import     -> add-file::import mod-id item lcx
        ast::item::function   -> add-file::function mod-path mod-id item lcx
        ast::item::extern     -> add-file::extern mod-path mod-id item lcx
        ast::item::ascription -> add-file::ascription mod-id item lcx
        ast::item::type       -> add-file::type mod-path mod-id item lcx
        ast::item::alias      -> add-file::alias mod-path mod-id item lcx
        ast::error            -> lcx
        kind -> std::panic "invalid ast {kind}"
      }

      add-file-rec mod-path mod-id items lcx
    }
  }
}

fn add-file::import mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let import = lcx::import {
    path: path.mods
    span: path.span
  }

  lcx with {
    imports: lcx.imports
      |> map::put (mod-id, path.name) import
  }
}

fn add-file::function mod-path mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let type, lcx = lcx::infer-type path.span lcx

  let body = ir::body {
    path:   list::append path.path mod-path
    locals: map
    inputs: []
    expr:   none
    type:   type
  }

  let id, lcx         = lcx::add-body body lcx
  let sub-mod-id, lcx = create-module mod-id path.mods lcx
  let existing        = lcx::get-body sub-mod-id path.name lcx

  match existing {
    none -> {
      // check for `->` shorthand, if present the body is the 4th child
      let body = match ast::nth 3 ast {
        ast::token  -> ast::nth-tree 4 ast
        ast::tree t -> t
      }

      let function = lcx::function {
        module: mod-id
        inputs: ast
          |> ast::nth-tree 2
          |> ast::assert ast::item::function::params
          |> ast::trees

        body: body
      }

      let lcx = lcx with {
        functions: lcx.functions
          |> map::put id function
      }

      lcx::put-body sub-mod-id path.name id lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate function `{path::format path}`"
        |> diagnostic::with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }
}

fn add-file::extern mod-path mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let body = ir::body {
    path:   list::append path.path mod-path
    locals: map
    inputs: []
    expr:   none
    type:   uir::type::dummy
  }

  let id, lcx         = lcx::add-body body lcx
  let sub-mod-id, lcx = create-module mod-id path.mods lcx
  let existing        = lcx::get-body sub-mod-id path.name lcx

  match existing {
    none -> {
      let extern = lcx::extern {
        module: mod-id
        type:   ast::nth-tree 3 ast
      }

      let lcx = lcx with {
        externs: lcx.externs
          |> map::put id extern
      }

      lcx::put-body sub-mod-id path.name id lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate function `{path::format path}`"
        |> diagnostic::with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }
}

fn add-file::type mod-path mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let generics, lcx = add-file::generics
    <| ast::nth-tree 2 ast
    <| lcx

  let item = ast::nth-tree 4 ast

  match item.kind {
    ast::item::type::record -> {
      add-file::type::record
        <| mod-path
        <| mod-id
        <| path
        <| generics
        <| item
        <| lcx
    }

    ast::item::type::union -> {
      add-file::type::union
        <| mod-path
        <| mod-id
        <| path
        <| generics
        <| item
        <| lcx
    }

    ast::error -> lcx

    _ -> std::panic "add-file::type invalid item {item.kind}"
  }
}

fn add-file::type::record mod-path mod-id path generics item lcx {
  let record = uir::record {
    path:     list::append path.path mod-path
    generics: generics
    fields:   []
    span:     path.span
  }

  let id, lcx         = lcx::add-record record lcx
  let sub-mod-id, lcx = create-module mod-id path.mods lcx
  let existing        = lcx::get-type sub-mod-id path.name lcx

  match existing {
    none -> {
      let fields = item
        |> ast::trees-of ast::item::type::record::field

      let record = lcx::record {
        module: mod-id
        fields: fields
      }

      let lcx = lcx with {
        records: lcx.records
          |> map::put id record
      }

      lcx::put-record sub-mod-id path.name id lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate type `{path::format path}`"
        |> diagnostic::with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }
}

fn add-file::type::union mod-path mod-id path generics item lcx {
  let union = uir::union {
    path:     list::append path.path mod-path
    generics: generics
    variants: []
    span:     path.span
  }

  let union-id, lcx   = lcx::add-union union lcx
  let sub-mod-id, lcx = create-module mod-id path.mods lcx
  let existing        = lcx::get-type sub-mod-id path.name lcx

  match existing {
    none -> {
      let variants = item
        |> ast::trees-of ast::item::type::union::variant

      let variants, lcx = add-file::type::union::variants
       <| list::append path.mods mod-path
       <| sub-mod-id
       <| union-id
       <| 0
       <| variants
       <| lcx

      let union = lcx::union {
        module:   mod-id
        variants: variants
      }

      let lcx = lcx with {
        unions: lcx.unions
          |> map::put union-id union
      }

      lcx::put-union sub-mod-id path.name union-id lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate type `{path::format path}`"
        |> diagnostic::with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }
}

fn add-file::type::union::variants mod-path mod-id union-id n variants lcx {
  match variants {
    [] -> [], lcx
    [variant; ..rest] -> {
      let variant, lcx = add-file::type::union::variant
        <| mod-path
        <| mod-id
        <| union-id
        <| n
        <| variant
        <| lcx

      let variants, lcx = add-file::type::union::variants
        <| mod-path
        <| mod-id
        <| union-id
        <| n + 1
        <| rest
        <| lcx

      [variant; ..variants], lcx
    }
  }
}

fn add-file::type::union::variant mod-path mod-id union-id n ast lcx {
  let path = ast::nth-tree 0 ast
    |> path::info

  let sub-mod-id, lcx = create-module mod-id path.mods lcx

  let existing = lcx::get-variant sub-mod-id path.name lcx

  let lcx = match existing {
    none -> {
      lcx::put-variant
        <| sub-mod-id
        <| path.name
        <| union-id
        <| n
        <| lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate variant `{path::format path}`"
        |> diagnostic:: with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }

  let body = ir::body {
    path:   list::append path.path mod-path
    locals: map
    inputs: []
    expr:   none
    type:   uir::type::dummy
  }

  let body-id, lcx = lcx::add-body body lcx
  let existing = lcx::get-body sub-mod-id path.name lcx

  let lcx = match existing {
    none -> {
      lcx::put-body
        <| sub-mod-id
        <| path.name
        <| body-id
        <| lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate function `{path::format path}`"
        |> diagnostic:: with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }

  let variant = lcx::variant {
    module: sub-mod-id
    index:  n
    path:   list::append path.path mod-path
    cons:   body-id
    body:   ast
      |> ast::trees
      |> list::nth 1
    span:   path.span
  }

  variant, lcx
}

fn add-file::alias mod-path mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let generics, lcx = add-file::generics
    <| ast::nth-tree 2 ast
    <| lcx

  let alias = uir::alias {
    path:     list::append path.path mod-path
    generics: generics
    type:     uir::type::dummy
    span:     path.span
  }

  let id, lcx         = lcx::add-alias alias lcx
  let sub-mod-id, lcx = create-module mod-id path.mods lcx
  let existing        = lcx::get-type sub-mod-id path.name lcx

  match existing {
    none -> {
      let alias = lcx::alias {
        module: mod-id
        type:   ast::nth-tree 4 ast
      }

      let lcx = lcx with {
        aliases: lcx.aliases
          |> map::put id alias
      }

      lcx::put-alias sub-mod-id path.name id lcx
    }

    some -> {
      let diagnostic = diagnostic::error "duplicate type `{path::format path}`"
        |> diagnostic::with-label path.span "here"

      lcx::with-diagnostic diagnostic lcx
    }
  }
}

fn add-file::ascription mod-id ast lcx {
  let path = ast::nth-tree 1 ast
    |> path::info

  let sub-mod-id, lcx = create-module mod-id path.mods lcx

  let ascription = lcx::ascription {
    module: mod-id 
    submod: sub-mod-id
    name:   path.name
    type:   ast::nth-tree 3 ast
    span:   path.span
  }

  lcx with {
    ascriptions: [ascription; ..lcx.ascriptions]
  }
}

fn add-file::generics ast lcx {
  ast::assert ast::item::generics ast

  let generics, lcx = add-file::generics-rec
    <| ast::trees ast
    <| lcx

  generics, lcx
}

fn add-file::generics-rec generics lcx {
  match generics {
    []            -> [], lcx
    [ast; ..rest] -> {
      match ast::nth-ident 1 ast {
        none   -> add-file::generics-rec rest lcx
        some n -> {
          let var, lcx = lcx::fresh-var true lcx
          let rest, lcx = add-file::generics-rec rest lcx
          [n, var, ast.span; ..rest], lcx
        }
      }
    }
  }
}

fn lcx::add-module module lcx { 
  let id, uir = lcx.uir
    |> uir::program::add-module uir::module 

  id, lcx with { uir: uir }
}

fn lcx::put-module mod-id name id lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-module name id
    
  lcx::set-module mod-id mod lcx
}

fn lcx::set-module id mod lcx {
  lcx with {
    uir: uir::program::set-module id mod lcx.uir
  }
}

fn lcx::add-body body lcx {
  let id, uir = lcx.uir
    |> uir::program::add-body body

  id, lcx with { uir: uir }
}

fn lcx::put-body mod-id name id lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-body name id

  lcx::set-module mod-id mod lcx
}

fn lcx::put-type mod-id name type lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-type name type

  lcx::set-module mod-id mod lcx
}

fn lcx::add-record record lcx {
  let id, tcx = lcx.uir.tcx
    |> uir::tcx::add-record record

  id, lcx with {
    uir: lcx.uir with {
      tcx: tcx
    }
  }
}

fn lcx::put-record mod-id name id lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-type name
      <| uir::module::record id

  lcx::set-module mod-id mod lcx
}

fn lcx::add-union union lcx {
  let id, tcx = lcx.uir.tcx
    |> uir::tcx::add-union union

  id, lcx with {
    uir: lcx.uir with {
      tcx: tcx
    }
  }
}

fn lcx::put-union mod-id name id lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-type name
      <| uir::module::union id

  lcx::set-module mod-id mod lcx
}

fn lcx::put-variant mod-id name id n lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-variant name (id, n)

  lcx::set-module mod-id mod lcx
}

fn lcx::add-alias alias lcx {
  let id, tcx = lcx.uir.tcx
    |> uir::tcx::add-alias alias

  id, lcx with {
    uir: lcx.uir with {
      tcx: tcx
    }
  }
}

fn lcx::put-alias mod-id name id lcx {
  let mod = lcx.uir
    |> uir::program::module mod-id
    |> uir::module::put-type name
      <| uir::module::alias id

  lcx::set-module mod-id mod lcx
}
