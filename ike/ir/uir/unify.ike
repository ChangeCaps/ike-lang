import std::list
import std::string

fn tcx::unify : type -> type -> span -> tcx -> tcx
fn tcx::unify lhs rhs span tcx {
  match tcx::substitute-shallow lhs tcx {
    some lhs -> tcx::unify lhs rhs span tcx
    none     -> match tcx::substitute-shallow rhs tcx {
      some rhs -> tcx::unify lhs rhs span tcx
      none     -> {
        match lhs.kind == rhs.kind or set::has (lhs, rhs) tcx.cache {
          true  -> tcx
          false -> {
            let tcx = tcx with {
              cache: set::put (lhs, lhs) tcx.cache
            }

            match lhs.kind, rhs.kind {
              type::var var, _ -> {
                tcx::unify-var-type var rhs span tcx
              }

              _ , type::var var -> {
                tcx::unify-var-type var lhs span tcx
              }

              type::app lhs-app, type::app rhs-app -> {
                tcx::unify-app-app lhs lhs-app rhs rhs-app span tcx
              }
            }
          }
        }
      }
    }
  }
}

fn tcx::unify-var-type var type span tcx {
  let bounds = tcx::bounds var tcx

  let tcx = match bounds.number {
    true  -> tcx::require-number type span tcx
    false -> tcx
  }

  let tcx = bounds.fields
    |> map::list
    |> list::foldl tcx |tcx name, field| {
      tcx::require-field type name field span tcx
    }

  tcx with {
    subst: map::put var.index type tcx.subst
  }
}

fn tcx::unify-app-app lhs lhs-app rhs rhs-app span tcx {
  let unify-list = |lhs rhs span tcx| {
    list::zip rhs lhs
      |> list::foldl tcx |tcx lhs, rhs| {
        tcx::unify lhs rhs span tcx
      }
  }

  match lhs-app, rhs-app {
    app::integer, app::integer -> tcx
    app::string,  app::string  -> tcx
    app::boolean, app::boolean -> tcx
    app::unit,    app::unit    -> tcx

    app::list lhs, app::list rhs -> {
      tcx::unify lhs rhs span tcx
    }

    app::tuple lhs, app::tuple rhs -> {
      match list::len lhs == list::len rhs {
        true  -> unify-list lhs rhs span tcx
        false -> {
          let error = diagnostic::error "cannot unify tuples with lengths `{list::len lhs}` and `{list::len rhs}`"
            |> diagnostic::with-label span "required here" 

          tcx::with-error error tcx
        }
      }
    }

    app::function (lhs-in, lhs-out), app::function (rhs-in, rhs-out) -> {
      tcx
        |> tcx::unify lhs-in rhs-in span
        |> tcx::unify lhs-out rhs-out span
    }

    app::record (lhs-id, lhs-generics), app::record (rhs-id, rhs-generics) -> {
      match lhs-id == rhs-id {
        true  -> unify-list lhs-generics rhs-generics span tcx
        false -> {
          let lhs-fmt = tcx::format-type lhs tcx
          let rhs-fmt = tcx::format-type rhs tcx
          let error = diagnostic::error "cannot unify types `{lhs-fmt}` and `{rhs-fmt}`"
            |> diagnostic::with-label span "required here"

          tcx::with-error error tcx
        }
      }
    }

    app::union (lhs-id, lhs-generics), app::union (rhs-id, rhs-generics) -> {
      match lhs-id == rhs-id {
        true  -> unify-list lhs-generics rhs-generics span tcx
        false -> {
          let lhs-fmt = tcx::format-type lhs tcx
          let rhs-fmt = tcx::format-type rhs tcx
          let error = diagnostic::error "cannot unify types `{lhs-fmt}` and `{rhs-fmt}`"
            |> diagnostic::with-label span "required here"

          tcx::with-error error tcx
        }
      }
    }

    app::alias (lhs-id, lhs-generics), app::alias (rhs-id, rhs-generics) -> {
      match lhs-id == rhs-id {
        true  -> unify-list lhs-generics rhs-generics span tcx
        false -> {
          let lhs = tcx::expand-alias lhs-id lhs-generics tcx
          tcx::unify lhs rhs span tcx
        }
      }
    }

    app::alias (id, generics), _ -> {
      let lhs = tcx::expand-alias id generics tcx
      tcx::unify lhs rhs span tcx
    }

    _, app::alias (id, generics) -> {
      let rhs = tcx::expand-alias id generics tcx
      tcx::unify lhs rhs span tcx
    }

    _, _ -> {
      let lhs-fmt = tcx::format-type lhs tcx
      let rhs-fmt = tcx::format-type rhs tcx
      let error = diagnostic::error "cannot unify types `{lhs-fmt}` and `{rhs-fmt}`"
        |> diagnostic::with-label span "required here"

      tcx::with-error error tcx
    }
  }
}

fn tcx::expand-alias id generics tcx {
  let alias = tcx::alias id tcx

  let subst = alias.generics
    |> list::map |_, var, _| var
    |> list::zip generics
    |> map::from-list

  type::substitute subst alias.type
}

fn tcx::require-number type span tcx {
  match tcx::substitute-shallow type tcx {
    some type -> tcx::require-number type span tcx
    none -> match type.kind {
      type::var var -> {
        let bounds = (tcx::bounds var tcx) with {
          number: true
        }

        tcx::set-bounds var bounds tcx
      }

      type::app app::integer -> tcx

      type::app _ -> {
        let fmt = tcx::format-type type tcx
        let error = diagnostic::error "type `{fmt}` is not a number"
          |> diagnostic::with-label span "required here"

        tcx::with-error error tcx
      }
    } 
  }
}

fn tcx::require-field type name field span tcx {
  match tcx::substitute-shallow type tcx {
    some type -> tcx::require-field type name field span tcx
    none -> match type.kind {
      type::var var -> {
        let bounds = tcx::bounds var tcx

        match map::get name bounds.fields {
          some current -> {
            tcx::unify field current span tcx
          }

          none -> {
            let bounds = bounds with {
              fields: map::put name field bounds.fields
            }

            tcx::set-bounds var bounds tcx
          }
        }
      }

      type::app app::record (id, generics) -> {
        let record = tcx::record id tcx

        match record.fields |> (list::find |n, _| n == name) {
          some (_, type) -> {
            let subst = record.generics
              |> list::map |_, v, _| v
              |> list::zip generics
              |> map::from-list

            let type = type::substitute subst type
            tcx::unify type field span tcx
          }

          none -> {
            let fmt = tcx::format-type type tcx
            let error = diagnostic::error "type `{fmt}` is not have a field `{name}`"
              |> diagnostic::with-label span "required here"

            tcx::with-error error tcx
          }
        }
      }

      type::app app::alias (id, generics) -> {
        let type = tcx::expand-alias id generics tcx
        tcx::require-field type name field span tcx
      }

      type::app _ -> {
        let fmt = tcx::format-type type tcx
        let error = diagnostic::error "type `{fmt}` is not have fields"
          |> diagnostic::with-label span "required here"

        tcx::with-error error tcx
      }
    }
  }
}

fn tcx::substitute-shallow type tcx {
  match type.kind {
    type::var var -> map::get var.index tcx.subst
    type::app     -> none
  }
}

fn tcx::format-type type tcx {
  let vars = tcx::enumerate-vars type tcx

  let names = vars
    |> set::list
    |> list::map |var, _| var
    |> list::enumerate
    |> list::foldl map |map n, var| {
      let name = tcx::generate-var-name n
      map::put var name map
    }

  tcx::format-type' type names [] 0 tcx
}

fn tcx::format-type' type names seen p tcx {
  match type.kind {
    type::var var -> match list::contains var seen {
      true  -> ".."
      false -> match tcx::substitute-shallow type tcx {
        some type -> tcx::format-type' type names [var; ..seen] p tcx
        none -> {
          let name = names
            |> map::get var
            |> option::assert

          "'{name}"
        }
      }
    }

    type::app app -> match app {
      app::integer   -> "int"
      app::string    -> "str"
      app::boolean   -> "bool"
      app::unit      -> "{{}}"

      app::list item -> {
        let item = tcx::format-type' item names seen 0 tcx
        "[{item}]"
      }
      
      app::tuple items -> {
        items
          |> list::map |t| tcx::format-type' t names seen 1 tcx
          |> string::join ", "
      }

      app::function (in, out) -> {
        let in = tcx::format-type' in names seen 1 tcx
        let out = tcx::format-type' out names seen 0 tcx

        match p > 0 {
          true  -> "({in} -> {out})"
          false -> "{in} -> {out}"
        }
      }

      app::record (id, generics) -> {
        let record = tcx::record id tcx

        generics
          |> list::map |t| tcx::format-type' t names seen 1 tcx
          |> list::push <| string::join "::" record.path
          |> string::join " "
      }

      app::union (id, generics) -> {
        let union = tcx::union id tcx

        generics
          |> list::map |t| tcx::format-type' t names seen 1 tcx
          |> list::push <| string::join "::" union.path
          |> string::join " "
      }

      app::alias (id, generics) -> {
        let alias = tcx::alias id tcx

        generics
          |> list::map |t| tcx::format-type' t names seen 1 tcx
          |> list::push <| string::join "::" alias.path
          |> string::join " "
      }
    }
  }
}

fn tcx::enumerate-vars type tcx -> tcx::enumerate-vars' [] tcx type
fn tcx::enumerate-vars' seen tcx type {
  match type.kind {
    type::var var -> match list::contains var seen {
      true  -> set
      false -> match map::get var.index tcx.subst {
        some type -> tcx::enumerate-vars' [var; ..seen] tcx type
        none -> {
          let bounds = tcx::bounds var tcx

          bounds.fields
            |> map::list
            |> list::map |_, type| type
            |> list::map <| tcx::enumerate-vars' [var; ..seen] tcx 
            |> list::foldl set set::union
            |> set::put (var, type.span)
        }
      }
    }

    type::app app -> match app {
      app::list item -> tcx::enumerate-vars' seen tcx item

      app::function (in, out) -> {
        let in = tcx::enumerate-vars' seen tcx in
        let out = tcx::enumerate-vars' seen tcx out

        set::union in out
      }

      app::tuple items -> {
        items
          |> list::map <| tcx::enumerate-vars' seen tcx
          |> list::foldl set set::union
      }

      app::record (_, generics) -> {
        generics
          |> list::map <| tcx::enumerate-vars' seen tcx
          |> list::foldl set set::union
      }

      app::union (_, generics) -> {
        generics
          |> list::map <| tcx::enumerate-vars' seen tcx
          |> list::foldl set set::union
      }

      app::alias (_, generics) -> {
        generics
          |> list::map <| tcx::enumerate-vars' seen tcx
          |> list::foldl set set::union
      }

      _ -> set
    }
  }
}

fn tcx::generate-var-name idx {
  let letters = string::graphemes "abcdefghijklmnopqrstuvwxyz"
  let letter = list::nth (idx % list::len letters) letters |> option::assert

  match idx > list::len letters {
    false -> letter
    true  -> "{letter}{tcx::generate-var-name <| idx / list::len letters}"
  }
}
