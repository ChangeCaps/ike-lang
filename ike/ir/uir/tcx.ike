import ike::diagnostic

import std::map
import std::set
import std::option

type tcx = {
  records: map int record
  unions:  map int union
  aliases: map int alias  
  bounds:  map int bounds
  subst:   map int type
  cache:   set (type, type)
  errors:  [diagnostic]
}

type bounds = {
  number: bool
  fields: map str type
}

alias generics = [str, var, span]

type record = {
  path:     [str]
  generics: generics
  fields:   [str, type]
  span:     span
}

type union = {
  path:     [str]
  generics: generics
  variants: [variant]
  span:     span
}

type variant = {
  path: [str]
  body: option type
}

type alias = {
  path:     [str]
  generics: generics
  type:     type
  span:     span
}

type record::id = { index: int }
type union::id  = { index: int }
type alias::id  = { index: int }

fn tcx : tcx
fn tcx {
  tcx {
    records: map
    unions:  map
    aliases: map
    bounds:  map
    subst:   map
    cache:   set
    errors:  []
  }
}

fn tcx::add-record : record -> tcx -> record::id, tcx
fn tcx::add-record record tcx {
  let index = map::len tcx.records
  let tcx = tcx with {
    records: map::put index record tcx.records
  }

  record::id { index: index }, tcx
}

fn tcx::add-union : union -> tcx -> union::id, tcx
fn tcx::add-union union tcx {
  let index = map::len tcx.unions
  let tcx = tcx with {
    unions:  map::put index union tcx.unions
  }

  union::id { index: index }, tcx
}

fn tcx::add-alias : alias -> tcx -> alias::id, tcx
fn tcx::add-alias alias tcx {
  let index = map::len tcx.aliases
  let tcx = tcx with {
    aliases: map::put index alias tcx.aliases
  }

  alias::id { index: index }, tcx
}

fn tcx::set-record : record::id -> record -> tcx -> tcx
fn tcx::set-record id record tcx {
  tcx with {
    records: map::put id.index record tcx.records
  }
}

fn tcx::set-union : union::id -> union -> tcx -> tcx
fn tcx::set-union id union tcx {
  tcx with {
    unions: map::put id.index union tcx.unions
  }
}

fn tcx::set-alias : alias::id -> alias -> tcx -> tcx
fn tcx::set-alias id alias tcx {
  tcx with {
    aliases: map::put id.index alias tcx.aliases
  }
}

fn tcx::record : record::id -> tcx -> record
fn tcx::record id tcx {
  tcx.records
    |> map::get id.index
    |> option::expect "malformed record::id"
}

fn tcx::union : union::id -> tcx -> union
fn tcx::union id tcx {
  tcx.unions
    |> map::get id.index
    |> option::expect "malformed union::id"
}

fn tcx::alias : alias::id -> tcx -> alias
fn tcx::alias id tcx {
  tcx.aliases
    |> map::get id.index
    |> option::expect "malformed alias::id"
}

fn tcx::set-bounds : var -> bounds -> tcx -> tcx
fn tcx::set-bounds var bounds tcx {
  let bounds = tcx.bounds
    |> map::put var.index bounds

  tcx with { bounds: bounds }
}

fn tcx::bounds : var -> tcx -> bounds
fn tcx::bounds var tcx {
  tcx.bounds
    |> map::get var.index
    |> option::some-or bounds::default
}

fn tcx::add-subst : var -> type -> tcx -> tcx
fn tcx::add-subst var type tcx {
  let subst = tcx.subst
    |> map::put var.index type

  tcx with { subst: subst }
}

fn tcx::subst : var -> tcx -> option type
fn tcx::subst var tcx -> map::get var.index tcx.subst

fn tcx::cache : type -> type -> tcx -> tcx
fn tcx::cache lhs rhs tcx {
  let cache = tcx.cache
    |> set::put (lhs, rhs)

  tcx with { cache: cache }
}

fn tcx::cached : type -> type -> tcx -> bool
fn tcx::cached lhs rhs tcx -> set::has (lhs, rhs) tcx.cache

fn tcx::with-error : diagnostic -> tcx -> tcx
fn tcx::with-error diagnostic tcx {
  tcx with {
    errors: [diagnostic; ..tcx.errors]
  }
}

fn tcx::fresh-var : bool -> tcx -> var, tcx
fn tcx::fresh-var generic tcx {
  let index = map::len tcx.bounds
  let tcx = tcx with {
    bounds: map::put index bounds::default tcx.bounds
  }

  let var = var {
    index:   index
    generic: generic
  }

  var, tcx
}

fn bounds::default : bounds
fn bounds::default {
  bounds {
    number: false
    fields: map
  }
}

/// Create a new instance of a type.
fn tcx::instantiate : type -> tcx -> type, tcx
fn tcx::instantiate type tcx {
  let type = tcx::substitute type tcx

  let vars = tcx::enumerate-vars type tcx  
    |> set::list

  let new-vars, subst, tcx = vars
    |> list::foldl ([], map, tcx) |new-vars, subst, tcx var, span| {
      let new-var, tcx = tcx::fresh-var false tcx
      let type = type {
        kind: type::var new-var
        span: span
      }

      [new-var; ..new-vars], map::put var type subst, tcx
    }

  let tcx = new-vars
    |> list::foldl tcx |tcx var| {
      let bounds = tcx::bounds var tcx

      let new-bounds = bounds {
        number: bounds.number
        fields: bounds.fields
          |> map::list
          |> list::map |n, t| n, type::substitute subst t
          |> map::from-list
      }

      tcx::set-bounds var new-bounds tcx
    }

  type::substitute subst type, tcx
}

fn tcx::substitute : type -> tcx -> type
fn tcx::substitute type tcx {
  match type.kind {
    type::var var -> match map::get var.index tcx.subst {
      some type -> tcx::substitute type tcx
      none      -> type
    }

    type::app app -> match app {
      app::integer -> type
      app::string  -> type
      app::boolean -> type
      app::unit    -> type

      app::list item -> {
        let item = tcx::substitute item tcx
        type::list item type.span
      }

      app::tuple items -> {
        let items = items
          |> list::map |t| tcx::substitute t tcx
        type::tuple items type.span
      }

      app::function (in, out) -> {
        let in = tcx::substitute in tcx
        let out = tcx::substitute out tcx
        type::function in out type.span
      }

      app::record (id, generics) -> {
        let generics = generics
          |> list::map |t| tcx::substitute t tcx
        type::record id generics type.span
      }

      app::union (id, generics) -> {
        let generics = generics
          |> list::map |t| tcx::substitute t tcx
        type::union id generics type.span
      }

      app::alias (id, generics) -> {
        let generics = generics
          |> list::map |t| tcx::substitute t tcx
        type::alias id generics type.span
      }
    }
  }
}
