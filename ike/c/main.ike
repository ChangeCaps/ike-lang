import std::list
import std::map
import std::string
import std::some
import std::none
import std::todo
import std::panic
import std::option

import ike::ir
import ike::ir::tir

fn codegen : tir::body::id -> tir::program -> str
fn codegen entry tir {
  let codegen = codegen {
    tir:   tir
    temp:  0
    types: []
    funcs: []
    impls: []
    lines: []
    lists: map
  }

  let codegen = tir.bodies
    |> map::list
    |> list::foldl codegen |codegen body-id, body| {
      codegen::body body-id body codegen
    }

  let types = codegen.types
    |> list::reverse
    |> string::join "\n\n"

  let funcs = codegen.funcs
    |> list::reverse
    |> string::join "\n\n"

  let impls = codegen.impls
    |> list::reverse
    |> string::join "\n\n"

  "#include <ike/types.h>\n#include <ike/gc.h>\n\n{types}\n\n{funcs}\n\n{impls}"
}

type codegen = {
  tir:   tir::program

  temp:  int

  /// Forward type declarations
  types: [str]

  /// Forward function declarations
  funcs: [str]

  /// Implementations
  impls: [str]

  lines: [str]

  /// List types
  lists: map tir::type str
}

fn codegen::body : int -> tir::body -> codegen -> codegen
fn codegen::body body-id body codegen {
  match body.expr {
    some -> codegen::body::code body-id body codegen
    none -> codegen::body::extern body-id body codegen
  }
}

fn codegen::body::extern body-id body codegen {
  match body.path {
    ["std"; "io"; "print"] -> {
      let body-name = "ike_body_{body-id}"
      let open = "{{"

      let codegen = codegen
        |> codegen::with-type "typedef struct {body-name}_input {body-name}_input;"
        |> codegen::with-type "struct {body-name}_input {open}\n  ike_string input_0;\n}};"

      let signature = "void {body-name}({body-name}_input *input, ike_unit *output)"

      let vtable-call = ".call = (typeof({body-name}_vtable.call)){body-name},"

      let vtable = "{body-name}_vtable = {open}\n  {vtable-call}\n}"

      codegen
        |> codegen::with-func "{signature};"
        |> codegen::with-func "static const ike_function_vtable {vtable};"
        |> codegen::with-impl "{signature} {open} printf(\"%s\", input->input_0->contents); }}"
    }

    _ -> panic "unimplemented {body.path}"
  }
}

fn codegen::body::code body-id body codegen {
  let inputs, out, codegen = body.inputs
    |> list::foldr ([], body.type, codegen) |_ inputs, type, codegen| {
      let in, out = match type {
        tir::type::function (in, out) -> in, out
        _ -> panic "unreachable"
      }

      let codegen, type = codegen::type in codegen
      [type; ..inputs], out, codegen
    }

  let inputs = inputs
    |> list::enumerate
    |> list::map |i, type| "    {type} input_{i};"
    |> string::join "\n"

  let body-name = "ike_body_{body-id}"

  let open = "{{"
  let codegen = codegen
    |> codegen::with-type "typedef struct {body-name}_input {body-name}_input;"
    |> codegen::with-type "struct {body-name}_input {open}\n{inputs}\n}};"

  let codegen, out = codegen::type out codegen

  let locals, codegen = body.locals
    |> map::list
    |> list::foldr ([], codegen) |index, local locals, codegen| {
      let codegen, type = codegen::type local.type codegen 
      ["{type} local_{index};"; ..locals], codegen
    }

  let locals = locals
    |> list::map |local| "  {local}"
    |> string::join "\n"

  let signature = "void {body-name}({body-name}_input *input, {out} *output)"

  let codegen = body.inputs
    |> list::enumerate
    |> list::foldl codegen |codegen index, pattern| {
      codegen::pattern::assign pattern "input->input_{index}" codegen
    }

  let codegen, expr = codegen::expr (option::assert body.expr) codegen
  let codegen = codegen::with-line "*output = {expr};" codegen

  let lines = codegen.lines
    |> list::map |line| "  {line}"
    |> list::reverse
    |> string::join "\n"

  let codegen = codegen with { lines: [] }

  let vtable-call = ".call = (typeof({body-name}_vtable.call)){body-name},"

  let vtable = "{body-name}_vtable = {open}\n  {vtable-call}\n}"

  codegen
    |> codegen::with-func "{signature};"
    |> codegen::with-func "static const ike_function_vtable {vtable};"
    |> codegen::with-impl "{signature} {open}\n{locals}\n\n{lines}\n}}"
}

fn codegen::type : tir::type -> codegen -> codegen, str
fn codegen::type type codegen {
  match type {
    tir::type::integer -> codegen, "ike_int"
    tir::type::boolean -> codegen, "ike_bool"
    tir::type::string  -> codegen, "ike_string"
    tir::type::unit    -> codegen, "ike_unit"

    tir::type::list item -> match map::get type codegen.lists {
      some type -> codegen, type
      none -> {
        let codegen, item = codegen::type item codegen

        let index = map::len codegen.lists
        let list = "ike_list_{index}"

        let decl = "typedef IKE_LIST({item}) {type}"
        let codegen = codegen with {
          lists: map::put type list codegen.lists
        }

        codegen::with-impl decl codegen, list
      }
    }

    tir::type::function -> codegen, "ike_function"
    
    _ -> todo "{type}"
  }
}

fn codegen::pattern::assign : tir::pattern -> str -> codegen -> codegen
fn codegen::pattern::assign pattern value codegen {
  match pattern.kind {
    ir::pattern::wildcard -> codegen

    ir::pattern::binding local-id -> {
      codegen::with-line "local_{local-id.index} = {value};" codegen
    }

    _ -> todo "{pattern.kind}"
  }
}

fn codegen::expr : tir::expr -> codegen -> codegen, str
fn codegen::expr expr codegen {
  match expr.kind {
    ir::expr::integer value -> codegen, "{value}"
    ir::expr::boolean value -> codegen, "{value}"
    ir::expr::string value -> codegen, "ike_string_new(\"{value}\")"

    ir::expr::local local-id -> codegen, "local_{local-id.index}"

    ir::expr::body body-id -> {
      let body = tir::body body-id codegen.tir

      match list::len body.inputs {
        0 -> {
          let codegen, output = codegen::temp expr.type codegen
          let codegen = codegen
            |> codegen::with-line "ike_body_{body-id.index}(NULL, &{output});"

          codegen, output
        }

        _ -> {
          let codegen, function = codegen::temp expr.type codegen

          let input-size = "sizeof(ike_body_{body-id.index}_input)"
          let size = "(sizeof *{function}) + {input-size}"

          let codegen = codegen
            |> codegen::with-line "// initialize function `{body.path}`"
            |> codegen::with-line "{function} = ike_alloc({size});"
            |> codegen::with-line "{function}->vtable = &ike_body_{body-id.index}_vtable;"
            |> codegen::with-line "{function}->remaining = {list::len body.inputs};"
            |> codegen::with-line "{function}->end = {function}->input + {input-size};"

          codegen, "{function}"
        }
      }
    }

    ir::expr::let_ (pattern, value) -> {
      let codegen, value = codegen::expr value codegen
      let codegen = codegen::pattern::assign pattern value codegen
      codegen, "((ike_unit) {{}})"
    }

    ir::expr::call (callee, value) -> {
      let codegen, output = codegen::temp expr.type codegen
      let codegen, input = codegen::temp value.type codegen

      let codegen, callee = codegen::expr callee codegen
      let codegen, value = codegen::expr value codegen

      let codegen = codegen
        |> codegen::with-line "{input} = {value};" 
        |> codegen::with-line "ike_call({callee}, &{input}, (sizeof {input}), &{output});" 

      codegen, "{output}"
    }

    ir::expr::block exprs -> {
      let value, codegen = exprs
        |> list::foldl (none, codegen) |value, codegen expr| {
          let codegen, expr = codegen::expr expr codegen
          some expr, codegen
        }

      codegen, option::some-or "((ike_unit) {{}})" value
    }

    _ -> todo "{expr.kind}"
  }
}

fn codegen::temp type codegen {
  let codegen, type = codegen::type type codegen
  let temp = "temp_{codegen.temp}"
  let codegen = codegen::with-line "{type} {temp};" codegen
  codegen with { temp: codegen.temp + 1 }, temp
}

fn codegen::with-type type codegen {
  codegen with {
    types: [type; ..codegen.types]
  }
}

fn codegen::with-func func codegen {
  codegen with {
    funcs: [func; ..codegen.funcs]
  }
}

fn codegen::with-impl impl codegen {
  codegen with {
    impls: [impl; ..codegen.impls]
  }
}

fn codegen::with-line line codegen {
  codegen with {
    lines: [line; ..codegen.lines]
  }
}
