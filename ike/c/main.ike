import std::list
import std::map
import std::string
import std::some
import std::none
import std::todo
import std::panic
import std::option

import ike::ir
import ike::ir::tir

fn codegen : tir::body::id -> tir::program -> str
fn codegen entry tir {
  let codegen = codegen {
    tir:     tir
    temp:    0
    types:   []
    funcs:   []
    impls:   []
    lines:   []
    tuples:  map
    hashes:  map
    equals:  map
    formats: map
    records: map
    unions:  map
  }

  let codegen = tir.bodies
    |> map::list
    |> list::lfold codegen |codegen body-id, body| {
      codegen::body body-id body codegen
    }

  let types = codegen.types
    |> list::reverse
    |> string::join "\n\n"

  let funcs = codegen.funcs
    |> list::reverse
    |> string::join "\n\n"

  let impls = codegen.impls
    |> list::reverse
    |> string::join "\n\n"

  string::join "\n" [
    "#include <ike/types.h>"
    "#include <ike/gc.h>"
    "#include <ike/function.h>"
    "#include <ike/string.h>"
    "#include <ike/os.h>"
    "#include <ike/hash.h>"
    ""
    "#include <stdio.h>"
    types
    "\n"
    funcs
    "\n"
    impls
    "\n"
    "int main() {{ ike_body_0(); }}"
  ]
}

type codegen = {
  tir:   tir::program

  temp:  int

  /// Forward type declarations
  types: [str]

  /// Forward function declarations
  funcs: [str]

  /// Implementations
  impls: [str]

  lines: [str]

  tuples:  map tir::type str
  hashes:  map tir::type str
  equals:  map tir::type str
  formats: map tir::type str
  records: map tir::record::id str
  unions:  map tir::union::id str
}

fn codegen::body : int -> tir::body -> codegen -> codegen
fn codegen::body index body codegen {
  match body.expr {
    some expr -> codegen::body::code index body expr codegen
    none      -> codegen::body::extern index body codegen
  }
}

fn codegen::body::extern index body codegen {
  let inputs = |count| {
    let inputs, output = list::repeat count {}
      |> list::lfold ([], body.type) |inputs, output _| {
        match output {
          tir::type::function (input, output) -> [input; ..inputs], output
          _ -> panic "unreachable"
        }
      }

    list::reverse inputs, output
  }

  match body.path {
    ["std"; "io"; "print"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "printf(\"%s\", input->input_0->contents);"
      ]

      let inputs, output = inputs 1

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "string"; "prepend"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "*output = ike_string_concat(input->input_0, input->input_1);"
      ]

      let inputs, output = inputs 2

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "os"; "exit"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "ike_os_exit(input->input_0);"
      ]

      let inputs, output = inputs 1

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "os"; "execute"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "*output = (void *)ike_os_execute(input->input_0);"
      ]

      let inputs, output = inputs 1

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "fs"; "read"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "*output = (void *)ike_fs_read(input->input_0);"
      ]

      let inputs, output = inputs 1

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "fs"; "write"] -> {
      let name = codegen::body::name index
      
      let contents = codegen::lines [
        "*output = (void *)ike_fs_write(input->input_0);"
      ]

      let inputs, output = inputs 2

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    ["std"; "hash"] -> {
      let name = codegen::body::name index
      
      let inputs, output = inputs 1
      let input = list::first inputs
        |> option::assert

      let codegen, hash = codegen::hash input codegen

      let contents = codegen::lines [
        "*output = {hash}(input->input_0);"
      ]

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }

    _ -> panic "unimplemented {body.path}"
  }
}

fn codegen::body::name index -> "ike_body_{index}"

fn codegen::body::code index body expr codegen {
  let name = codegen::body::name index

  let inputs, output = body.inputs
    |> list::lfold ([], body.type) |inputs, output _| {
      match output {
        tir::type::function (input, output) -> [input; ..inputs], output 
        _ -> panic "unreachable"
      }
    }

  let inputs = list::reverse inputs

  let codegen, locals = body.locals
    |> map::list
    |> list::lfold (codegen, []) |codegen, locals index, local| {
      let codegen, type = codegen::type local.type codegen
      let local = "    {type} local_{index}; // {local.name}"
      codegen, [local; ..locals]
    }

  let locals = string::join "\n" locals

  let codegen = body.inputs
    |> list::enumerate
    |> list::lfold codegen |codegen i, input| {
      codegen::pattern::assign input "input->input_{i}" codegen
    }
  
  let codegen, expr = codegen::expr expr codegen

  let lines = codegen.lines
    |> list::reverse
    |> list::map |line| "    {line}"
    |> string::join "\n"

  let codegen = codegen with { lines: [] }

  match inputs {
    [] -> {
      let codegen, output = codegen::type output codegen

      let contents = string::join "\n" [
        "    /* locals */"
        locals
        "    /* body */"
        lines
        "    /* return */"
        "    return {expr};"
      ]

      codegen
        |> codegen::with-func "{output} {name}();"
        |> codegen::with-impl "{output} {name}() {{\n{contents}\n}}"
    }

    _ -> {
      let contents = string::join "\n" [
        "    /* locals */"
        locals
        "    /* body */"
        lines
        "    /* return */"
        "    *output = {expr};"
      ]

      codegen::body::with-inputs
        <| name
        <| inputs
        <| output
        <| contents
        <| codegen
    }
  }
}

fn codegen::body::with-inputs name inputs output contents codegen {
  let vtable = vtable {
    call: "{name}_call"
  }

  let codegen, input  = codegen::body::input  vtable.call inputs codegen

  let codegen, signature = codegen::body::signature
    <| vtable.call
    <| input
    <| output
    <| codegen

  let codegen = codegen
    |> codegen::with-func "{signature};"
    |> codegen::with-impl "{signature} {{\n{contents}\n}}"

  let codegen, vtable = codegen::body::vtable vtable.call vtable codegen
  let codegen, output = codegen::type output codegen

  let init-contents = codegen::lines [
    "ike_function function = ike_alloc(sizeof *function);"
    ""
    "function->vtable    = &{vtable};"
    "function->remaining = {list::len inputs};"
    "function->size      = 0;"
    ""
    "return function;"
  ]

  codegen
    |> codegen::with-func "ike_function {name}();"
    |> codegen::with-impl "ike_function {name}() {{\n{init-contents}\n}}"
}

type vtable = {
  call: str
}

fn codegen::lines lines {
  lines
    |> list::map |line| "    {line}"
    |> string::join "\n"
}

fn codegen::body::vtable name vtable codegen {
  let call = "    .call = (ike_function_vtable_call){vtable.call},"
  let vtable = "static const ike_function_vtable {name}_vtable = {{\n{call}\n}};"

  codegen::with-func vtable codegen, "{name}_vtable"
}

fn codegen::body::input name inputs codegen {
  let codegen, inputs = codegen::types inputs codegen

  let inputs = inputs
    |> list::enumerate
    |> list::map |i, type| "    {type} input_{i};"
    |> string::join "\n"

  let struct = "typedef struct {{\n{inputs}\n}} {name}_input;"

  codegen::with-func struct codegen, "{name}_input"
}

fn codegen::body::signature name input output codegen {
  let codegen, output = codegen::type output codegen

  codegen, "void {name}({input} *input, {output} *output)"
}

fn codegen::temp type codegen {
  let codegen, type = codegen::type type codegen
  let temp = "temp_{codegen.temp}"
  let codegen = codegen::with-line "{type} {temp};" codegen
  codegen with { temp: codegen.temp + 1 }, temp
}

fn codegen::with-type type codegen {
  codegen with {
    types: [type; ..codegen.types]
  }
}

fn codegen::with-func func codegen {
  codegen with {
    funcs: [func; ..codegen.funcs]
  }
}

fn codegen::with-impl impl codegen {
  codegen with {
    impls: [impl; ..codegen.impls]
  }
}

fn codegen::with-line line codegen {
  codegen with {
    lines: [line; ..codegen.lines]
  }
}
